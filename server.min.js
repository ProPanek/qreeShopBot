/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./server.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./db/db_qree.js":
/*!***********************!*\
  !*** ./db/db_qree.js ***!
  \***********************/
/*! exports provided: createQree, editQree, findGame, approxQrCount */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createQree", function() { return createQree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editQree", function() { return editQree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findGame", function() { return findGame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "approxQrCount", function() { return approxQrCount; });
/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ "pg");
/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pg_escape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pg-escape */ "pg-escape");
/* harmony import */ var pg_escape__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pg_escape__WEBPACK_IMPORTED_MODULE_1__);
__webpack_require__(/*! dotenv */ "dotenv").config();



function createDBclient() {
  return new pg__WEBPACK_IMPORTED_MODULE_0__["Client"]({
    connectionString: process.env.DATABASE_URL
  });
}

async function createQree(
  qrData,
  qrLink,
  name,
  platform,
  region,
  size,
  uploader_discord_id,
  uploader_name
) {
  const client = createDBclient();
  try {
    await client.connect();

    await client.query(
      `INSERT INTO qre_items(qr_data, qr_link, name, platform, region, size, uploader_discord_id, uploader_name) 
      VALUES('${qrData}', '${qrLink}', '${name}' , '${platform}', '${region}', '${size}', '${uploader_discord_id}' , '${uploader_name}')`
    );
    await client.end();
    console.log("DB -> save qr in DB");
  } catch (e) {
    console.log(e);
  }
}

async function editQree(id, jiraLogin, jiraPassword, jiraSubdomain) {
  const client = createDBclient();
  await client.connect();
  try {
    await client.query(
      `UPDATE qre_items SET jira_email = '${jiraLogin}', jira_api_key = '${jiraPassword}', jira_subdomain = '${[
        jiraSubdomain
      ]}'  WHERE id = '${id}'`
    );
    console.log("DB -> save jira credentials in DB");
    await client.end();
  } catch (e) {
    console.log(e);
  }
}

async function findGame(name) {
  const client = createDBclient();
  try {
    await client.connect();
    const res = await client.query(
      `SELECT * FROM qre_items WHERE name ILIKE '%${name}%';`
    );
    console.log("DB -> game found in DB");
    await client.end();
    return res;
  } catch (e) {
    console.log(e);
  }
}

async function approxQrCount() {
  const client = createDBclient();
  try {
    await client.connect();
    const res = await client.query(`SELECT COUNT(*) FROM qre_items`);
    console.log("DB -> counting qr codes");
    await client.end();
    return res;
  } catch (e) {
    console.log(e);
  }
}


/***/ }),

/***/ "./helpers/helpers.js":
/*!****************************!*\
  !*** ./helpers/helpers.js ***!
  \****************************/
/*! exports provided: parseDropboxLink, parseGDriveLink, createASCIIQrCode, createEmbeddedHelper, limitlessFetchMessages, createEmbeddedAnswer, checkIfDM, regexes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDropboxLink", function() { return parseDropboxLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGDriveLink", function() { return parseGDriveLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createASCIIQrCode", function() { return createASCIIQrCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmbeddedHelper", function() { return createEmbeddedHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "limitlessFetchMessages", function() { return limitlessFetchMessages; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmbeddedAnswer", function() { return createEmbeddedAnswer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkIfDM", function() { return checkIfDM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regexes", function() { return regexes; });
/* harmony import */ var qrcode_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! qrcode-generator */ "qrcode-generator");
/* harmony import */ var qrcode_generator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(qrcode_generator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var discord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! discord.js */ "discord.js");
/* harmony import */ var discord_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(discord_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var discord_paginationembed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! discord-paginationembed */ "discord-paginationembed");
/* harmony import */ var discord_paginationembed__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(discord_paginationembed__WEBPACK_IMPORTED_MODULE_2__);




function parseDropboxLink(link) {
  let string = link;
  string = string.split("/");
  string[5] = "?dl=1";
  string = string.join("/");
  return string;
}

function parseGDriveLink(link) {
  return link.replace(/\/file\/d\/(.+)\/(.+)/, "/uc?export=download&id=$1");
}

function createASCIIQrCode(link) {
  let qr = qrcode_generator__WEBPACK_IMPORTED_MODULE_0___default()(0, "M");
  qr.addData(`${link}`);
  qr.make();
  return qr.createASCII();
}

function createEmbeddedHelper(
  serverInvokers,
  receivedMessage,
  destination
) {
  const embeds = [];

  if (checkIfDM(receivedMessage)) {
    embeds.push(
      new discord_js__WEBPACK_IMPORTED_MODULE_1__["MessageEmbed"]()
        .addField("**COMMAND**: ", "```search```")
        .addField(
          "Description",
          "```search -  It's available on channels and DM's, it will search for all games containing typed phrase. (emoji navigation in dm's is a little buggy but it works)```"
        )
        .addField("Command: ", '```!qre search "<name>" ```')
        .addField("Example: ", '```!qre search "Super Castlevania IV"```')
    );
  } else {
    embeds.push(
      new discord_js__WEBPACK_IMPORTED_MODULE_1__["MessageEmbed"]()
        .addField("**COMMAND**: ", "```upload```")
        .addField(
          "Description",
          "```upload - upload is available only in certain servers on " +
            "Discord and only available to users containing special role(s). " +
            "Remember about quotation marks in title of the game!```"
        )
        .addField(
          "Arguments: ",
          "```" +
            "<platform> - GBA, NES, SNES, 3DS, NEW3DS, DSI, ESHOP, NEW 3DS, NEO GEO \n\n" +
            "<regions> - USA, JPN, EUR, GLOBAL, HACK \n\n" +
            "<size> - *KB, *MB, *GB \n" +
            "```"
        )
        .addField(
          "Command: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            ' upload <url> "<name>" <platform> <region> <size> ```'
        )

        .addField(
          "Example: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            ' upload https://files.catbox.moe/au9pkx.cia "Super Castlevania IV" GBA USA 5MB ```'
        )
    );

    embeds.push(
      new discord_js__WEBPACK_IMPORTED_MODULE_1__["MessageEmbed"]()
        .addField("**COMMAND**: ", "```search```")
        .addField(
          "Description",
          "```search -  It's available on channels and DM's, it will search for all games containing typed phrase. (emoji navigation in dm's is a little buggy but it works)```"
        )
        .addField(
          "Command: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            ' search "<name>" ```'
        )
        .addField(
          "Example: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            ' search "Super Castlevania IV"```'
        )
    );

    embeds.push(
      new discord_js__WEBPACK_IMPORTED_MODULE_1__["MessageEmbed"]()
        .addField("**COMMAND**: ", "```invoke```")
        .addField(
          "Description",
          "```invoke - server only command which lets you change the command for invoking bot the default is always !qre```"
        )
        .addField(
          "Command: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            " invoke <new_command> ```"
        )
        .addField(
          "Example: ",
          "```" +
            serverInvokers.get(receivedMessage.guild.id) +
            "invoke %qre```"
        )
    );
  }

  return (
    new discord_paginationembed__WEBPACK_IMPORTED_MODULE_2__["Embeds"]()
      .setArray(embeds)
      .setAuthorizedUsers([receivedMessage.author.id])
      .setChannel(
        destination === "pm" ? receivedMessage.author : receivedMessage.channel
      )
      .setPageIndicator(true)
      .setPage(1)
      // Methods below are for customising all embeds
      .setTitle("Qr Code 3DS help")
      .setDescription(
        "=========================================================="
      )
      .addField(
        "NOTE:",
        "```links - you can provide direct link or normal sharing links from google and dropbox it will be automatically converted into direct ones```"
      )
      .setFooter("")
      .setColor(0xffffff)
      .setNavigationEmojis({
        back: "◀",
        jump: "↗",
        forward: "▶",
        delete: "🗑"
      })
      .setTimeout(600000)
  );
  // .on('start', () => console.log('Started!'))
  // // Upon a user deleting the embed
  // .on('finish', (user) => console.log(`Finished! User: ${user.username}`))
  // // Upon a user reacting to the embed
  // .on('react', (user, emoji) => console.log(`Reacted! User: ${user.username} | Emoji: ${emoji.name} (${emoji.id})`))
  // // Upon the awaiting time expired
  // .on('expire', () => console.warn('Expired!'))
  // // Upon non-PaginationEmbed error (e.g: Discord API Error)
  // .on('error', console.error)
}

async function limitlessFetchMessages(channel, limit = 9000) {
  const sum_messages = [];
  let last_id;

  while (true) {
    const options = { limit: 100 };
    if (last_id) {
      options.before = last_id;
    }

    const messages = await channel.messages.fetch(options);
    sum_messages.push(...messages.array());
    last_id = messages.last().id;

    if (messages.size !== 100 || sum_messages >= limit) {
      break;
    }
  }

  return sum_messages;
}

function createEmbeddedAnswer(args, receivedMessage, destination) {
  const embeds = [];
  args.map(
    (
      { id, qr_data, qr_link, name, platform, region, size, uploader_name },
      index
    ) => {
      embeds.push(
        new discord_js__WEBPACK_IMPORTED_MODULE_1__["MessageEmbed"]()
          .addField("Name: ", name, true)
          .addField("Page", index + 1, true)
          .addField("QR: ", "```" + qr_data + "```")
          .addField("QR link: ", qr_link, true)
          .addField("DB ID: ", id, true)
          .addBlankField()
          .addField("Platform: ", platform, true)
          .addField("Region: ", region, true)
          .addField("Size: ", size, true)
          .addField("Author: ", uploader_name, true)
      );
    }
  );

  return (
    new discord_paginationembed__WEBPACK_IMPORTED_MODULE_2__["Embeds"]()
      .setArray(embeds)
      .setAuthorizedUsers([receivedMessage.author.id])
      .setChannel(
        destination === "pm" ? receivedMessage.author : receivedMessage.channel
      )
      .setPageIndicator(true)
      .setPage(1)
      // Methods below are for customising all embeds
      .setTitle("Qr Code 3DS games search collection")
      .setDescription(
        "=========================================================="
      )
      .setFooter("")
      .setColor(0xffffff)
      .setNavigationEmojis({
        back: "◀",
        jump: "↗",
        forward: "▶",
        delete: "🗑"
      })
      .setTimeout(600000)
  );
  // .on('start', () => console.log('Started!'))
  // // Upon a user deleting the embed
  // .on('finish', (user) => console.log(`Finished! User: ${user.username}`))
  // // Upon a user reacting to the embed
  // .on('react', (user, emoji) => console.log(`Reacted! User: ${user.username} | Emoji: ${emoji.name} (${emoji.id})`))
  // // Upon the awaiting time expired
  // .on('expire', () => console.warn('Expired!'))
  // // Upon non-PaginationEmbed error (e.g: Discord API Error)
  // .on('error', console.error)
}

function checkIfDM(receivedMessage) {
  return receivedMessage.channel.type === "dm";
}

const regexes = {
  DROPBOX: /\b(\w*dropbox\w*)\b/g,
  GDRIVE: /\b(\w*drive.google.com\w*)\b/g,
  URL: /(http|ftp|https):\/\/([\w_-]+(?:(?:\.[\w_-]+)+))([\w.,@?^=%&:/~+#-]*[\w@?^=%&/~+#-])?/g,
  ARGUMENTS: /\b(\w*GBA|NES|SNES|3DS|NEW3DS|DSI|ESHOP|NEW 3DS|NEO GEO\w*)\b|(http|ftp|https):\/\/([\w_-]+(?:(?:\.[\w_-]+)+))([\w.,@?^=%&:/~+#-]*[\w@?^=%&/~+#-])?|\w+|"(?:\\"|[^"])+"|\'(?:\\'|[^'])+'|\S+/g,
  TITLE: /"(?:\\"|[^"])+"|\'(?:\\'|[^'])+'/g,
  REGIONS: /\b(\w*USA|JPN|EUR|GLOBAL|HACK\w*)\b/gi,
  PLATFORMS: /\b(\w*GBA|NES|SNES|3DS|NEW3DS|DSI|ESHOP|NEW 3DS|NEO GEO\w*)\b/gi,
  SIZE: /\b(\w*MB|GB|KB\w*)\b/gi,
  SCRAPER_TITLE: /([^\(]+)|\((.*?)\)|/g
};
//(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?\w+|"(?:\\"|[^"])+"|'(?:\\'|[^"])+'|\w+


/***/ }),

/***/ "./models/database.js":
/*!****************************!*\
  !*** ./models/database.js ***!
  \****************************/
/*! exports provided: initializeDb */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializeDb", function() { return initializeDb; });
/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pg */ "pg");
/* harmony import */ var pg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pg__WEBPACK_IMPORTED_MODULE_0__);
__webpack_require__(/*! dotenv */ "dotenv").config();


async function initializeDb() {
  try {
    const client = await new pg__WEBPACK_IMPORTED_MODULE_0__["Client"]({
      connectionString: process.env.DATABASE_URL
    });
    await client.connect();
    await client.query(
      "CREATE TABLE IF NOT EXISTS qre_items(id SERIAL PRIMARY KEY, " +
        "qr_data text not null, " +
        "qr_link varchar not null, " +
        "name varchar not null, " +
        "platform varchar not null, " +
        "region varchar not null," +
        "size varchar not null," +
        "uploader_discord_id varchar not null," +
        "uploader_name varchar not null" +
        ")"
    );

    client.end();
  } catch (e) {
    console.log(e);
  }
}


/***/ }),

/***/ "./server.js":
/*!*******************!*\
  !*** ./server.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var discord_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! discord.js */ "discord.js");
/* harmony import */ var discord_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(discord_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jimp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jimp */ "jimp");
/* harmony import */ var jimp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jimp__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node-fetch */ "node-fetch");
/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var qrcode_reader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! qrcode-reader */ "qrcode-reader");
/* harmony import */ var qrcode_reader__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(qrcode_reader__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/helpers */ "./helpers/helpers.js");
/* harmony import */ var _models_database__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/database */ "./models/database.js");
/* harmony import */ var _db_db_qree__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./db/db_qree */ "./db/db_qree.js");
__webpack_require__(/*! dotenv */ "dotenv").config();








void (async function() {
  try {
    await Object(_models_database__WEBPACK_IMPORTED_MODULE_5__["initializeDb"])();
    console.log("DB -> init DB");
  } catch (e) {
    console.log(e);
  }

  try {
    await client.login(process.env.BOT_TOKEN);
  } catch (e) {
    console.log(e);
  }
})();

const client = new discord_js__WEBPACK_IMPORTED_MODULE_0__["Client"]();
let botInvoker = process.env.BOT_DEFAULT_INVOKE;
let serverInvokers = new Map();

client.on("ready", async () => {
  console.log("On Discord!");
  console.log("Connected as " + client.user.tag);
  console.log("Servers:");
  client.guilds.forEach(guild => {
    serverInvokers.set(guild.id, botInvoker);
    console.log(" - " + guild.id);
    guild.channels.forEach(channel => {
      console.log(` -- ${channel.name} (${channel.type}) - ${channel.id}`);
    });

    console.log(serverInvokers);
  });

  setInterval(async () => {
    const qrCount = await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["approxQrCount"])();
    qrCount.rows.map(async ({ count }) => {
      await client.user.setActivity(`QR Codes count: ${count}`, {
        type: "PLAYING"
      });
    });
  }, 60000);
});

client.on("message", receivedMessage => {
  if (receivedMessage.author === client.user) {
    // Prevent bot from responding to its own messages
    return;
  }

  if (receivedMessage.channel.type === "dm") {
    if (receivedMessage.content.startsWith(`${botInvoker}`)) {
      processCommand(receivedMessage);
    } else {
      return receivedMessage.channel.send(
        `You need to specify which command you want to use type "!qre help" to display available commands`
      );
    }
  } else {
    if (
      receivedMessage.content.startsWith(
        `${serverInvokers.get(receivedMessage.guild.id)}`
      )
    ) {
      processCommand(receivedMessage);
    }
  }
});

function processCommand(receivedMessage) {
  let fullCommand, primaryCommand;

  Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["checkIfDM"])(receivedMessage)
    ? (fullCommand = receivedMessage.content.substr(botInvoker.length + 1))
    : (fullCommand = receivedMessage.content.substr(
        serverInvokers.get(receivedMessage.guild.id).length + 1
      ));

  const messageArguments = fullCommand.match(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].ARGUMENTS);

  if (messageArguments !== null && messageArguments.length) {
    primaryCommand = messageArguments[0]; // The first word directly after the exclamation is the command
  }

  if (
    primaryCommand === "" ||
    primaryCommand === null ||
    primaryCommand === undefined
  ) {
    Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["checkIfDM"])(receivedMessage)
      ? receivedMessage.channel.send(
          `You need to specify which command you want to use type "!qre help" to display available commands`
        )
      : receivedMessage.channel.send(
          `You need to specify which command you want to use type "${serverInvokers.get(
            receivedMessage.guild.id
          )} help" to display available commands`
        );
    return;
  }

  if (primaryCommand === "help") {
    return Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["createEmbeddedHelper"])(serverInvokers, receivedMessage).build();
  }

  if (!Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["checkIfDM"])(receivedMessage)) {
    if (
      process.env.BOT_PERMISSIONS_GUILD.includes(receivedMessage.guild.id) &&
      receivedMessage.member.roles.some(r =>
        process.env.BOT_PERMISSIONS_ROLES.includes(r.name)
      )
    ) {
      if (primaryCommand === "upload") {
        return handleGameUpload(messageArguments, receivedMessage);
      }

      if (primaryCommand === "invoke") {
        return changeInvokeCommand(messageArguments, receivedMessage);
      }

      if (primaryCommand === "scrap") {
        return scrapChannelForQrCodes(messageArguments, receivedMessage);
      }

      if (primaryCommand === "edit") {
        return handleGameEdit(messageArguments, receivedMessage);
      }
    } else {
      return receivedMessage.channel.send(
        "You have no permissions to use this commands"
      );
    }
  }

  if (primaryCommand === "search") {
    return searchGame(messageArguments, receivedMessage);
  }

  return receivedMessage.channel.send(`Command not found`);
}

async function scrapChannelForQrCodes(messageArguments, receivedMessage) {
  if (receivedMessage.channel.type === "dm") {
    return receivedMessage.channel.send(
      `This command is available only in servers`
    );
  }

  Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["limitlessFetchMessages"])(receivedMessage.channel).then(async messages => {
    for (const item of messages) {
      console.log(messages.author.name);
      if (!!item.attachments.size) {
        const metaInformation = item.content
          .match(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].SCRAPER_TITLE)
          .map(Function.prototype.call, String.prototype.trim)
          .filter(function(el) {
            if (el !== null && el !== " ") return el;
          });
        const name = metaInformation[0];
        metaInformation.shift();

        const regionIndex = metaInformation.findIndex(value =>
          _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].REGIONS.test(value)
        );
        const platformIndex = metaInformation.findIndex(value =>
          _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].PLATFORMS.test(value)
        );
        const sizeIndex = metaInformation.findIndex(value =>
          _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].SIZE.test(value)
        );

        const res = await node_fetch__WEBPACK_IMPORTED_MODULE_2___default()(
          `${item.attachments.values().next().value.proxyURL}`
        );
        const buffer = await res.buffer();
        const img = await jimp__WEBPACK_IMPORTED_MODULE_1___default.a.read(buffer);
        const qr = new qrcode_reader__WEBPACK_IMPORTED_MODULE_3___default.a();

        const value = await new Promise((resolve, reject) => {
          qr.callback = (err, v) => (err != null ? reject(err) : resolve(v));
          qr.decode(img.bitmap);
        });

        const obj = {
          name: name.replace(/^"(.*)"$/, "$1").replace(/'/g, "''"),
          qr_link: value.result,
          qr_data: await Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["createASCIIQrCode"])(value.result),
          platform: metaInformation[platformIndex] || "N/A",
          region: metaInformation[regionIndex] || "N/A",
          size: metaInformation[sizeIndex] || "N/A",
          uploader_discord_id: item.author.id,
          uploader_name: messages.author.username
        };

        const { rows } = await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["findGame"])(obj.name);
        console.log(!rows.length);
        if (!rows.length) {
          try {
            await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["createQree"])(
              obj.qr_data,
              obj.qr_link,
              obj.name,
              obj.platform,
              obj.region,
              obj.size,
              obj.uploader_discord_id,
              obj.uploader_name
            );
            await receivedMessage.author.send(
              "Saving in database! " + obj.name
            );
          } catch (e) {
            console.log(e);
            await receivedMessage.author.send(
              "something went wrong, send it to developer: \n" +
                "```diff\n- " +
                e +
                "```"
            );
          }
        } else {
          await receivedMessage.author.send("Game is already in DB" + obj.name);
        }
      }
    }

    return receivedMessage.channel.send(`fetching messages`);
  });

  if (messageArguments.length > 3) {
    return receivedMessage.channel.send(
      `Too much arguments for invoke command`
    );
  }

  if (messageArguments[1]) {
    serverInvokers.set(receivedMessage.guild.id, messageArguments[1]);
    return receivedMessage.channel.send(
      `Successfully changed your invoke command`
    );
  }
}

function changeInvokeCommand(messageArguments, receivedMessage) {
  if (receivedMessage.channel.type === "dm") {
    return receivedMessage.channel.send(
      `This command is available only in servers`
    );
  }

  if (messageArguments.length > 3) {
    return receivedMessage.channel.send(
      `Too much arguments for invoke command`
    );
  }

  if (messageArguments[1]) {
    serverInvokers.set(receivedMessage.guild.id, messageArguments[1]);
    return receivedMessage.channel.send(
      `Successfully changed your invoke command`
    );
  }
}

async function handleGameUpload(messageArguments, receivedMessage) {
  if (messageArguments.length !== 6) {
    return receivedMessage.channel.send(
      `invalid arguments count for upload command`
    );
  }
  const urlIndex = messageArguments.findIndex(value => _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].URL.test(value));

  if (!urlIndex) {
    return receivedMessage.channel.send(
      `invalid arguments \`URL\` for upload command`
    );
  }
  const titleIndex = messageArguments.findIndex(value =>
    _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].TITLE.test(value)
  );
  if (!titleIndex) {
    return receivedMessage.channel.send(
      `invalid arguments \`TITLE\` for upload command`
    );
  }
  const regionIndex = messageArguments.findIndex(value =>
    _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].REGIONS.test(value)
  );
  if (!titleIndex) {
    return receivedMessage.channel.send(
      `invalid arguments \`REGION\` for upload command`
    );
  }
  const platformIndex = messageArguments.findIndex(value =>
    _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].PLATFORMS.test(value)
  );
  if (!platformIndex) {
    return receivedMessage.channel.send(
      `invalid arguments \`PLATFORM\` for upload command`
    );
  }
  const sizeIndex = messageArguments.findIndex(value =>
    _helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].SIZE.test(value)
  );
  if (!sizeIndex) {
    return receivedMessage.channel.send(
      `invalid arguments \`SIZE\` for upload command`
    );
  }

  if (messageArguments[urlIndex].match(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].GDRIVE)) {
    messageArguments[urlIndex] = Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["parseGDriveLink"])(messageArguments[urlIndex]);
  } else if (messageArguments[urlIndex].match(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["regexes"].DROPBOX)) {
    messageArguments[urlIndex].slice(-1) === "0"
      ? (messageArguments[urlIndex] = Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["parseDropboxLink"])(
          messageArguments[urlIndex]
        ))
      : null;
  }

  const obj = {
    name: messageArguments[titleIndex]
      .replace(/^"(.*)"$/, "$1")
      .replace(/'/g, "''"),
    qr_link: messageArguments[urlIndex],
    qr_data: await Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["createASCIIQrCode"])(messageArguments[urlIndex]),
    platform: messageArguments[platformIndex],
    region: messageArguments[regionIndex],
    size: messageArguments[sizeIndex],
    uploader_discord_id: receivedMessage.author.id,
    uploader_name: receivedMessage.author.username
  };

  const { rows } = await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["findGame"])(obj.name);
  const text =
    rows.length === 0
      ? "```diff\n" +
        "+ This is how it will look, save in database? Type 'yes'/'no'" +
        "\n```"
      : "```diff\n" +
        "+ There are games with similar name, check by searching them first before uploading" +
        "\n```" +
        "```diff\n" +
        "+ This is how it will look, save in database? Type 'yes'/'no' or 'search' if you want to check about what games I was talking about :)" +
        "\n```";

  await receivedMessage.channel.send(
    "```" +
      obj.qr_data +
      "\nLink: " +
      obj.qr_link +
      "\n\nName: " +
      obj.name +
      "\nPlatform: " +
      obj.platform +
      "\nRegion: " +
      obj.region +
      "\nSize: " +
      obj.size +
      "\nUploader: " +
      obj.uploader_name +
      "```" +
      text
  );

  const collector = new discord_js__WEBPACK_IMPORTED_MODULE_0__["MessageCollector"](
    receivedMessage.channel,
    m => m.author.id === receivedMessage.author.id,
    { time: 60000 }
  );
  collector.on("collect", async message => {
    if (message.content === "yes") {
      try {
        await receivedMessage.channel.send("Saving in database!");
        await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["createQree"])(
          obj.qr_data,
          obj.qr_link,
          obj.name,
          obj.platform,
          obj.region,
          obj.size,
          obj.uploader_discord_id,
          obj.uploader_name
        );
      } catch (e) {
        console.log(e);
        await receivedMessage.channel.send(
          "something went wrong, send it to developer: \n" +
            "```diff\n- " +
            e +
            "```"
        );
      }

      collector.stop();
    } else if (message.content === "no") {
      try {
        await receivedMessage.channel.send("Ok try again later :P");
      } catch (e) {
        console.log(e);
        await receivedMessage.channel.send(
          "something went wrong, send it to developer: \n" +
            "```diff\n- " +
            e +
            "```"
        );
      }
      collector.stop();
    } else if (message.content === "search") {
      try {
        await receivedMessage.channel.send(
          "```Ok, displaying games that I have found you can type 'yes'/'no' still```"
        );

        const QrCodesSearchResults = Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["createEmbeddedAnswer"])(
          rows,
          receivedMessage
        );
        await QrCodesSearchResults.build();
      } catch (e) {
        console.log(e);
        await receivedMessage.channel.send(
          "something went wrong, send it to developer: \n" +
            "```diff\n- " +
            e +
            "```"
        );
      }
    }
  });

  collector.on("end", async () => {
    await receivedMessage.channel.send("upload session ended");
  });
}

async function searchGame(messageArguments, receivedMessage) {
  try {
    // const games = await findGame(messageArguments[1])
    console.log(messageArguments);
    if (messageArguments.length !== 2) {
      return await receivedMessage.channel.send(
        `invalid arguments for search command`
      );
    }

    const name = messageArguments[1].replace(/^"(.*)"$/, "$1");
    const { rows } = await Object(_db_db_qree__WEBPACK_IMPORTED_MODULE_6__["findGame"])(name);
    if (rows.length === 0) {
      await receivedMessage.author.send(
        `I didn't find anything called \`${messageArguments[1]}\``
      );
    } else {
      const QrCodesSearchResults = Object(_helpers_helpers__WEBPACK_IMPORTED_MODULE_4__["createEmbeddedAnswer"])(rows, receivedMessage);
      await QrCodesSearchResults.build();
    }
  } catch (e) {
    console.log(e);
    await receivedMessage.channel.send(
      "something went wrong, send it to developer: \n" +
        "```diff\n- " +
        e +
        "```"
    );
  }
}

async function handleGameEdit(messageArguments, receivedMessage) {
  try {
    // const games = await findGame(messageArguments[1])
    console.log(messageArguments);
    const id = parseInt(messageArguments[1]);
    // if (messageArguments.length !== 2) {
    //   return await receivedMessage.channel.send(
    //     `invalid arguments for search command`
    //   );
    // }
    //
    // const name = messageArguments[1].replace(/^"(.*)"$/, "$1");
    // const { rows } = await findGame(name);
    // if (rows.length === 0) {
    //   await receivedMessage.author.send(
    //     `I didn't find anything called \`${messageArguments[1]}\``
    //   );
    // } else {
    //   const QrCodesSearchResults = createEmbeddedAnswer(rows, receivedMessage);
    //   await QrCodesSearchResults.build();
    // }
  } catch (e) {
    console.log(e);
    await receivedMessage.channel.send(
      "something went wrong, send it to developer: \n" +
        "```diff\n- " +
        e +
        "```"
    );
  }
}


/***/ }),

/***/ "discord-paginationembed":
/*!******************************************!*\
  !*** external "discord-paginationembed" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("discord-paginationembed");

/***/ }),

/***/ "discord.js":
/*!*****************************!*\
  !*** external "discord.js" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("discord.js");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("dotenv");

/***/ }),

/***/ "jimp":
/*!***********************!*\
  !*** external "jimp" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("jimp");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("node-fetch");

/***/ }),

/***/ "pg":
/*!*********************!*\
  !*** external "pg" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("pg");

/***/ }),

/***/ "pg-escape":
/*!****************************!*\
  !*** external "pg-escape" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("pg-escape");

/***/ }),

/***/ "qrcode-generator":
/*!***********************************!*\
  !*** external "qrcode-generator" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("qrcode-generator");

/***/ }),

/***/ "qrcode-reader":
/*!********************************!*\
  !*** external "qrcode-reader" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("qrcode-reader");

/***/ })

/******/ });